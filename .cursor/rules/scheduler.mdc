---
description: 스케줄러 규칙 및 스케줄링 작업 가이드
globs:
  - "app/utils/scheduler.py"
  - "app/main.py"
alwaysApply: false
---

# 스케줄러 규칙

## 스케줄러 개요

프로젝트는 `schedule` 라이브러리를 사용하여 주식 자동매매 스케줄러를 구현합니다.

## 스케줄러 구조

### 1. 스케줄러 클래스

`app/utils/scheduler.py`에 `StockScheduler` 클래스가 정의되어 있습니다:

```python
from app.utils.scheduler import StockScheduler

scheduler = StockScheduler()
scheduler.start()  # 스케줄러 시작
```

### 2. 스케줄러 시작/중지

`app/main.py`의 `lifespan` 이벤트에서 관리:

```python
from app.utils.scheduler import start_scheduler, stop_scheduler

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    start_scheduler()
    
    yield
    
    # Shutdown
    stop_scheduler()
```

## 스케줄 시간 설정

### 1. 스케줄 시간 상수

`SchedulerConfig` 클래스에 스케줄 시간이 정의되어 있습니다:

```python
class SchedulerConfig:
    SCHEDULE_ECONOMIC_DATA_UPDATE_1 = "06:05"
    SCHEDULE_ECONOMIC_DATA_UPDATE_2 = "23:00"
    SCHEDULE_VERTEX_AI_PREDICTION = "23:00"
    SCHEDULE_PARALLEL_ANALYSIS = "23:05"
    SCHEDULE_COMBINED_ANALYSIS = "23:45"
    SCHEDULE_AUTO_BUY = "23:50"
```

### 2. 시간대 설정

한국 시간대(KST)를 사용합니다:

```python
import pytz

korea_tz = pytz.timezone('Asia/Seoul')
now_korea = datetime.now(korea_tz)
```

## 스케줄 작업 작성 규칙

### 1. 작업 함수 정의

스케줄 작업은 명확한 함수로 정의합니다:

```python
def run_daily_analysis():
    """매일 실행되는 분석 작업"""
    try:
        logger.info("일일 분석 시작")
        # 분석 로직
        logger.info("일일 분석 완료")
    except Exception as e:
        logger.error(f"일일 분석 중 오류 발생: {str(e)}", exc_info=True)
```

### 2. 예외 처리

모든 스케줄 작업은 예외 처리를 포함해야 합니다:

```python
def scheduled_task():
    try:
        # 작업 로직
        pass
    except Exception as e:
        logger.error(f"스케줄 작업 실패: {str(e)}", exc_info=True)
        # Slack 알림 등 추가 처리
```

### 3. 로깅

스케줄 작업 시작/완료 시 로깅:

```python
def scheduled_task():
    logger.info("=" * 60)
    logger.info("스케줄 작업 시작")
    logger.info("=" * 60)
    
    try:
        # 작업 로직
        logger.info("작업 완료")
    except Exception as e:
        logger.error(f"작업 실패: {str(e)}")
    finally:
        logger.info("=" * 60)
```

### 4. 비동기 작업

비동기 작업은 별도로 처리:

```python
import asyncio

def run_async_task():
    """비동기 작업을 스케줄에서 실행"""
    try:
        loop = asyncio.get_event_loop()
        loop.run_until_complete(async_function())
    except Exception as e:
        logger.error(f"비동기 작업 실패: {str(e)}", exc_info=True)
```

## 스케줄 등록

### 1. 스케줄 등록 방법

```python
import schedule

# 매일 특정 시간에 실행
schedule.every().day.at("23:50").do(run_auto_buy)

# 매주 특정 요일에 실행
schedule.every().monday.at("09:00").do(run_weekly_analysis)

# 매 N분마다 실행
schedule.every(30).minutes.do(run_periodic_task)
```

### 2. 스케줄 실행 루프

별도 스레드에서 스케줄 실행:

```python
import threading
import time

def run_scheduler():
    """스케줄러 실행 루프"""
    while True:
        schedule.run_pending()
        time.sleep(1)

# 별도 스레드에서 실행
scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
scheduler_thread.start()
```

## 스케줄러 상태 관리

### 1. 스케줄러 시작/중지

```python
def start_scheduler():
    """스케줄러 시작"""
    global scheduler_thread
    if scheduler_thread and scheduler_thread.is_alive():
        logger.warning("스케줄러가 이미 실행 중입니다.")
        return
    
    scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
    scheduler_thread.start()
    logger.info("스케줄러가 시작되었습니다.")

def stop_scheduler():
    """스케줄러 중지"""
    schedule.clear()
    logger.info("스케줄러가 중지되었습니다.")
```

### 2. 스케줄러 상태 확인

```python
def get_scheduler_status():
    """스케줄러 상태 조회"""
    return {
        "running": scheduler_thread.is_alive() if scheduler_thread else False,
        "jobs": len(schedule.jobs)
    }
```

## 주요 스케줄 작업

### 1. 경제 데이터 업데이트

```python
schedule.every().day.at(SchedulerConfig.SCHEDULE_ECONOMIC_DATA_UPDATE_1).do(
    update_economic_data
)
```

### 2. AI 예측 실행

```python
schedule.every().day.at(SchedulerConfig.SCHEDULE_VERTEX_AI_PREDICTION).do(
    run_vertex_ai_prediction
)
```

### 3. 자동 매수

```python
schedule.every().day.at(SchedulerConfig.SCHEDULE_AUTO_BUY).do(
    run_auto_buy
)
```

## 주의사항

### 1. 시간대 처리

모든 스케줄 시간은 한국 시간대(KST) 기준입니다.

### 2. 중복 실행 방지

동일 작업이 중복 실행되지 않도록 락(lock) 사용:

```python
import threading

task_lock = threading.Lock()

def run_task():
    if not task_lock.acquire(blocking=False):
        logger.warning("작업이 이미 실행 중입니다.")
        return
    
    try:
        # 작업 로직
        pass
    finally:
        task_lock.release()
```

### 3. 장애 복구

스케줄 작업 실패 시 재시도 로직 고려:

```python
def run_task_with_retry(max_retries=3):
    for attempt in range(max_retries):
        try:
            # 작업 로직
            return
        except Exception as e:
            if attempt == max_retries - 1:
                logger.error(f"작업 실패 (재시도 {max_retries}회 모두 실패): {str(e)}")
                raise
            logger.warning(f"작업 실패 (재시도 {attempt + 1}/{max_retries}): {str(e)}")
            time.sleep(5)  # 재시도 전 대기
```

## 참고

- **스케줄러 로그**: `stock_scheduler.log` 파일에 기록
- **Slack 알림**: 중요한 스케줄 작업은 Slack으로 알림 전송
- **모니터링**: 스케줄러 상태를 주기적으로 확인
